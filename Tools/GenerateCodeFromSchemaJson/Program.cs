
using System.Data;
using System.Globalization;
using System.Text.RegularExpressions;
using System.Text;
using System.Reflection;
using System.Text.Json;
using static MyApp.Program;

namespace MyApp // Note: actual namespace depends on the project name.
{
    internal class Program
    {

        static void Main(string[] args)
        {

            Console.WriteLine("Starting...");

            var camelizer = new Regex("[^a-zA-Z0-9._]");

            var schema = GetColumnInfo();
            Console.WriteLine($"Found {schema.Count} columns to reconstruct...");

            var projectDirectory = new DirectoryInfo(Directory.GetCurrentDirectory());
            while (true)
            {
                if (projectDirectory is null)
                {
                    Console.WriteLine($"ERROR: Failed to find project folder! Exiting...");
                    return;
                }
                if ("gizmofort.connector.erpnext" == projectDirectory.Name)
                    break;
                projectDirectory = projectDirectory.Parent;
            }
            var outputFolder = Path.Combine(projectDirectory.FullName, @"Libs\GizmoFort.Connector.ERPNext\ERPTypes");
            Console.WriteLine($"Exporting generated code to {outputFolder}...");
            if (!Directory.Exists(outputFolder))
                Directory.CreateDirectory(outputFolder);

            var banner =
@"/********************************************************************
    This file has been auto-generated by GenerateCodeFromSchemaJson
    created date: " + DateTime.Now.ToString("G") + @"
********************************************************************/";

            var docTypesLines = new StringBuilder();
            var servicesUsings = new StringBuilder();
            var servicesProperties = new StringBuilder();
            var servicesConstructor = new StringBuilder();

            var modules = schema
                            .GroupBy(c => c.module)
                            .Select(g => g.Key)
                            .ToList();
            foreach (var module in modules)
            {
                var camelizedModule = camelizer.Replace($"{module}", "");

                var moduleFolder = Path.Combine(outputFolder, camelizedModule);
                if (!Directory.Exists(moduleFolder))
                    Directory.CreateDirectory(moduleFolder);

                var doctypes = schema
                                 .Where(c => c.module == module)
                                 .GroupBy(c => c.doctype)
                                 .Select(g => g.Key)
                                 .ToList();
                foreach (var doctype in doctypes)
                {
                    var camelizedDoctype = camelizer.Replace($"{doctype}", "");

                    Console.WriteLine($"Processing doctype '{camelizedModule}.{camelizedDoctype}'...");

                    var doctypeFolder = Path.Combine(outputFolder, camelizedModule, camelizedDoctype);
                    if (!Directory.Exists(doctypeFolder))
                        Directory.CreateDirectory(doctypeFolder);

                    var columnInfos = schema
                                        .Where(c => c.module == module
                                                    && c.doctype == doctype)
                                        .ToList();

                    var camelizedModuleNamespace = KeywordFixup(camelizedModule, "_");
                    var camelizedDoctypeNamespace = KeywordFixup(camelizedDoctype, "_");

                    var @namespace = $"GizmoFort.Connector.ERPNext.ERPTypes.{camelizedModuleNamespace}.{camelizedDoctypeNamespace}";
                    var typePrefix = $"ERP_{camelizedModule}_{camelizedDoctype}";
                    var doctypeEnumValue = $"{camelizedModule}_{camelizedDoctype}";
                    var modelClassName = $"ERP_{camelizedModule}_{camelizedDoctype}";
                    var serviceClassName = $"{camelizedModule}_{camelizedDoctype}_Service";

                    bool forceRegenerateAllFiles = false;

                    //
                    // user-customizable model file
                    //
                    {
                        var nameColumnType = columnInfos
                                                .Where(c => c.column_name == "name")
                                                .Select(c => c.data_type)
                                                .First();
                        var nameCSharpType = GetCSharpTypeFromDataType(nameColumnType, isNullable: false);

                        var fileContents =
@"" + banner + @"

using GizmoFort.Connector.ERPNext.WrapperTypes;

namespace " + @namespace + @"
{
    /*** NOTE: This file can be modified and will not be re-generated unless deleted ***/

    public partial class " + modelClassName + @" : ERPNextObjectBase
    {
        public static " + modelClassName + @" CreateNew(" + nameCSharpType + @" name /* add other parameters as needed */ )
        {
            " + modelClassName + @" obj = new()
            {
                Name = name
                /* set other properties from parameters here */
            };
            return obj;
        }
    }
}
";
                        var sb = new StringBuilder();

                        sb.Append(fileContents);

                        // create file if it doesn't exist
                        var filename = $"ERP_{camelizedModule}_{camelizedDoctype}.cs";
                        var outputFileFullPath = $"{doctypeFolder}\\{filename}";
                        if (forceRegenerateAllFiles || !File.Exists(outputFileFullPath))
                        {
                            if (File.Exists(outputFileFullPath))
                                File.Delete(outputFileFullPath);
                            using var file = new StreamWriter(outputFileFullPath);
                            file.WriteLine(sb.ToString()); // "sb" is the StringBuilder
                        }
                    }

                    //
                    // auto-generated model file
                    //
                    {
                        var propertiesBuilder = new StringBuilder();
                        foreach (var columnInfo in columnInfos)
                        {
                            var isNullable = columnInfo.is_nullable == "YES";
                            var cSharpType = GetCSharpTypeFromDataType(columnInfo.data_type, isNullable);
                            var columnName = columnInfo.column_name;
                            var hasLeadingUnderscore = columnName[..1] == "_";
                            var optionalUnderscore = hasLeadingUnderscore ? "_" : string.Empty;
                            var columnNamePascalCase = ConvertColumnNameToPascalCase(columnName);
                            var propertyName = $"{optionalUnderscore}{columnNamePascalCase}";
                            var safeColumnName = KeywordFixup(columnName, "@");
                            propertiesBuilder.AppendLine();
                            propertiesBuilder.AppendLine($"        [Column(\"{safeColumnName}\")]");
                            if (hasLeadingUnderscore)
                                propertiesBuilder.AppendLine("#pragma warning disable IDE1006 // Naming Styles");
                            propertiesBuilder.AppendLine($"        public {cSharpType} {propertyName}");
                            if (hasLeadingUnderscore)
                                propertiesBuilder.AppendLine("#pragma warning restore IDE1006 // Naming Styles");
                            propertiesBuilder.AppendLine($"        {{");
                            propertiesBuilder.AppendLine($"            get {{ return data.{safeColumnName}; }}");
                            propertiesBuilder.AppendLine($"            set {{ data.{safeColumnName} = value; }}");
                            propertiesBuilder.AppendLine($"        }}");
                        }
                        var properties = propertiesBuilder.ToString();


                        var fileContents =
@"" + banner + @"

using System;
using System.ComponentModel.DataAnnotations.Schema;
using GizmoFort.Connector.ERPNext.PublicTypes;
using GizmoFort.Connector.ERPNext.WrapperTypes;
using _DockType = GizmoFort.Connector.ERPNext.PublicTypes.DocType;

namespace " + @namespace + @"
{
    public partial class " + modelClassName + @" : ERPNextObjectBase
    {
        public " + modelClassName + @"() : this(new ERPObject(_DockType." + doctypeEnumValue + @")) { }
        public " + modelClassName + @"(ERPObject obj) : base(obj) { }

        public static string? GetColumnName(string propertyName)
        {
            return ERPNextObjectBase.GetColumnName<" + modelClassName + @">(propertyName);
        }
" + properties + @"

    }
}
";
                        var sb = new StringBuilder();

                        sb.Append(fileContents);

                        // create file
                        var filename = $"ERP_{camelizedModule}_{camelizedDoctype}.partial.cs";
                        var outputFileFullPath = $"{doctypeFolder}\\{filename}";
                        if (File.Exists(outputFileFullPath))
                            File.Delete(outputFileFullPath);
                        using var file = new StreamWriter(outputFileFullPath);
                        file.WriteLine(sb.ToString()); // "sb" is the StringBuilder
                    }

                    //
                    // user-customizable service file
                    //
                    {

                        var modelContent =
@"" + banner + @"

using GizmoFort.Connector.ERPNext.PublicInterfaces;
using GizmoFort.Connector.ERPNext.PublicInterfaces.SubServices;
using GizmoFort.Connector.ERPNext.PublicTypes;
using _DockType = GizmoFort.Connector.ERPNext.PublicTypes.DocType;

namespace " + @namespace + @"
{
    public class " + serviceClassName + @" : SubServiceBase<" + modelClassName + @">
    {
        public " + serviceClassName + @"(ERPNextClient client) : base(_DockType." + doctypeEnumValue + @", client) { }

        protected override " + modelClassName + @" FromERPObject(ERPObject obj)
        {
            return new " + modelClassName + @"(obj);
        }

        /* custom functions can be added here */

    }
}
";
                        var sb = new StringBuilder();

                        sb.Append(modelContent);

                        // create file if it doesn't exist
                        var filename = $"{camelizedModule}_{camelizedDoctype}_Service.cs";
                        var outputFileFullPath = $"{doctypeFolder}\\{filename}";
                        if (forceRegenerateAllFiles || !File.Exists(outputFileFullPath))
                        {
                            if (File.Exists(outputFileFullPath))
                                File.Delete(outputFileFullPath);
                            using var file = new StreamWriter(outputFileFullPath);
                            file.WriteLine(sb.ToString()); // "sb" is the StringBuilder
                        }
                    }

                    //
                    // doctypes lines
                    //
                    {
                        docTypesLines.AppendLine($"        public static readonly DocType {doctypeEnumValue} = new(\"{doctype}\");");
                    }

                    //
                    // services lines
                    //
                    {
                        servicesUsings.AppendLine($"using {@namespace};");
                        servicesProperties.AppendLine($"        public {serviceClassName} {serviceClassName} {{ get; }}");
                        servicesConstructor.AppendLine($"            this.{serviceClassName} = new {serviceClassName}(Client);");
                    }


                }


            }

            //
            // replace doctypes in:
            // gizmofort.connector.erpnext\Libs\GizmoFort.Connector.ERPNext\PublicTypes\DocType.cs
            //
            {
                Console.WriteLine(@"Replace old doctypes from GizmoFort.Connector.ERPNext\PublicTypes\DocType.cs...");
                var docTypeCsFile = Path.Combine(projectDirectory.FullName, @"Libs\GizmoFort.Connector.ERPNext\PublicTypes\DocType.cs");
                var docTypeCsFileTemp = $"{docTypeCsFile}temp";
                var lines = File.ReadAllLines(docTypeCsFile);
                using StreamWriter output = new(docTypeCsFileTemp);
                bool newLinesInserted = false;
                foreach (var line in lines)
                {
                    if (!line.Contains("public static readonly DocType"))
                    {
                        output.WriteLine(line);
                    }
                    else if (!newLinesInserted)
                    {
                        output.Write(docTypesLines.ToString());
                        newLinesInserted = true;
                    }
                }
                output.Flush();
                output.Close();
                File.Move(docTypeCsFileTemp, docTypeCsFile, true);
            }

            //
            // replace doctypes in:
            // gizmofort.connector.erpnext\Libs\GizmoFort.Connector.ERPNext\PublicTypes\DocType.cs
            //
            {
                Console.WriteLine(@"Replace main servies file at GizmoFort.Connector.ERPNext\PublicInterfaces\ERPNextServices.cs...");

                var fileContents =
@"" + banner + @"

" + servicesUsings.ToString() + @"
using GizmoFort.Connector.ERPNext.PublicInterfaces.SubServices;

namespace GizmoFort.Connector.ERPNext.PublicInterfaces
{
    public class ERPNextServices
    {
        public ERPNextClient Client { get; }
" + servicesProperties.ToString() + @"

        public ERPNextServices(string domain, string username, string password)
        {
            this.Client = new ERPNextClient(domain, username, password);
" + servicesConstructor.ToString() + @"

        }
    }
}
";
                var sb = new StringBuilder();

                sb.Append(fileContents);

                // create file
                var servicesFileFullPath = Path.Combine(projectDirectory.FullName, @"Libs\GizmoFort.Connector.ERPNext\PublicInterfaces\ERPNextServices.cs");
                if (File.Exists(servicesFileFullPath))
                    File.Delete(servicesFileFullPath);
                using var file = new StreamWriter(servicesFileFullPath);
                file.WriteLine(sb.ToString()); // "sb" is the StringBuilder
            }

            Console.WriteLine("Done!");

        }

        static string ConvertColumnNameToPascalCase(string columnName)
        {
            var noUnderscores = columnName.ToLower().Replace("_", " ");
            TextInfo info = CultureInfo.CurrentCulture.TextInfo;
            var propertyName = info.ToTitleCase(noUnderscores).Replace(" ", string.Empty);
            return propertyName;
        }

        static string KeywordFixup(string name, string prefix)
        {
            return name switch
            {
                "abstract" => $"{prefix}abstract",
                "as" => $"{prefix}as",
                "base" => $"{prefix}base",
                "bool" => $"{prefix}bool",
                "break" => $"{prefix}break",
                "byte" => $"{prefix}byte",
                "case" => $"{prefix}case",
                "catch" => $"{prefix}catch",
                "char" => $"{prefix}char",
                "checked" => $"{prefix}checked",
                "class" => $"{prefix}class",
                "const" => $"{prefix}const",
                "continue" => $"{prefix}continue",
                "decimal" => $"{prefix}decimal",
                "default" => $"{prefix}default",
                "delegate" => $"{prefix}delegate",
                "do" => $"{prefix}do",
                "double" => $"{prefix}double",
                "else" => $"{prefix}else",
                "enum" => $"{prefix}enum",
                "event" => $"{prefix}event",
                "explicit" => $"{prefix}explicit",
                "extern" => $"{prefix}extern",
                "false" => $"{prefix}false",
                "finally" => $"{prefix}finally",
                "fixed" => $"{prefix}fixed",
                "float" => $"{prefix}float",
                "for" => $"{prefix}for",
                "foreach" => $"{prefix}foreach",
                "goto" => $"{prefix}goto",
                "if" => $"{prefix}if",
                "implicit" => $"{prefix}implicit",
                "in" => $"{prefix}in",
                "int" => $"{prefix}int",
                "interface" => $"{prefix}interface",
                "internal" => $"{prefix}internal",
                "is" => $"{prefix}is",
                "lock" => $"{prefix}lock",
                "long" => $"{prefix}long",
                "namespace" => $"{prefix}namespace",
                "new" => $"{prefix}new",
                "null" => $"{prefix}null",
                "object" => $"{prefix}object",
                "operator" => $"{prefix}operator",
                "out" => $"{prefix}out",
                "override" => $"{prefix}override",
                "params" => $"{prefix}params",
                "private" => $"{prefix}private",
                "protected" => $"{prefix}protected",
                "public" => $"{prefix}public",
                "readonly" => $"{prefix}readonly",
                "ref" => $"{prefix}ref",
                "return" => $"{prefix}return",
                "sbyte" => $"{prefix}sbyte",
                "sealed" => $"{prefix}sealed",
                "short" => $"{prefix}short",
                "sizeof" => $"{prefix}sizeof",
                "stackalloc" => $"{prefix}stackalloc",
                "static" => $"{prefix}static",
                "string" => $"{prefix}string",
                "struct" => $"{prefix}struct",
                "switch" => $"{prefix}switch",
                "this" => $"{prefix}this",
                "throw" => $"{prefix}throw",
                "TRUE" => $"{prefix}TRUE",
                "try" => $"{prefix}try",
                "typeof" => $"{prefix}typeof",
                "uint" => $"{prefix}uint",
                "ulong" => $"{prefix}ulong",
                "unchecked" => $"{prefix}unchecked",
                "unsafe" => $"{prefix}unsafe",
                "ushort" => $"{prefix}ushort",
                "using" => $"{prefix}using",
                "virtual" => $"{prefix}virtual",
                "void" => $"{prefix}void",
                "volatile" => $"{prefix}volatile",
                "while" => $"{prefix}while",
                "add" => $"{prefix}add",
                "and" => $"{prefix}and",
                "alias" => $"{prefix}alias",
                "ascending" => $"{prefix}ascending",
                "args" => $"{prefix}args",
                "async" => $"{prefix}async",
                "await" => $"{prefix}await",
                "by" => $"{prefix}by",
                "descending" => $"{prefix}descending",
                "dynamic" => $"{prefix}dynamic",
                "equals" => $"{prefix}equals",
                "from" => $"{prefix}from",
                "get" => $"{prefix}get",
                "global" => $"{prefix}global",
                "group" => $"{prefix}group",
                "init" => $"{prefix}init",
                "into" => $"{prefix}into",
                "join" => $"{prefix}join",
                "let" => $"{prefix}let",
                "managed" => $"{prefix}managed",
                "nameof" => $"{prefix}nameof",
                "nint" => $"{prefix}nint",
                "not" => $"{prefix}not",
                "notnull" => $"{prefix}notnull",
                "nuint" => $"{prefix}nuint",
                "on" => $"{prefix}on",
                "or" => $"{prefix}or",
                "orderby" => $"{prefix}orderby",
                "partial" => $"{prefix}partial",
                "record" => $"{prefix}record",
                "remove" => $"{prefix}remove",
                "required" => $"{prefix}required",
                "select" => $"{prefix}select",
                "set" => $"{prefix}set",
                "unmanaged" => $"{prefix}unmanaged",
                "value" => $"{prefix}value",
                "var" => $"{prefix}var",
                "when" => $"{prefix}when",
                "where" => $"{prefix}where",
                "with" => $"{prefix}with",
                "yield" => $"{prefix}yield",
                _ => name
            };
        }

        //static string GetCSharpTypeDefaultAssignment(string cSharpType)
        //{
        //    return cSharpType switch
        //    {
        //        "int" => string.Empty,
        //        "decimal" => string.Empty,
        //        "string" => " = default!;",
        //        "DateTime" => string.Empty,
        //        "TimeSpan" => string.Empty,
        //        "DateOnly" => string.Empty,
        //        "long" => string.Empty,
        //        "int?" => " = default;",
        //        "decimal?" => " = default;",
        //        "string?" => " = default;",
        //        "DateTime?" => " = default;",
        //        "TimeSpan?" => " = default;",
        //        "DateOnly?" => " = default;",
        //        "long?" => " = default;",
        //        _ => string.Empty
        //    };
        //}

        static string GetCSharpTypeFromDataType(string dataType, bool isNullable)
        {
            return dataType switch
            {
                "int" => "int",
                "decimal" => "decimal",
                "text" => "string",
                "varchar" => "string",
                "datetime" => "DateTime",
                "time" => "TimeSpan",
                "date" => "DateOnly",
                "bigint" => "long",
                "longtext" => "string",
                _ => "object",
            } + (isNullable ? "?" : string.Empty);
        }

        static IList<ColumnInfo> GetColumnInfo()
        {
            var assembly = Assembly.GetExecutingAssembly();
            var resourceName = "GenerateCodeFromSchemaJson.schema_14.0.3.json";
            using var stream = assembly.GetManifestResourceStream(resourceName);
            using var reader = new StreamReader(stream!);
            var schemaJson = reader.ReadToEnd();
            var columnInfo = JsonSerializer.Deserialize<AllColumnInfos>(schemaJson);
            return columnInfo!.schema;
        }

        public class AllColumnInfos
        {
#pragma warning disable IDE1006 // Naming Styles
            public List<ColumnInfo> schema { get; set; } = null!;
#pragma warning restore IDE1006 // Naming Styles
        }

        public class ColumnInfo
        {
#pragma warning disable IDE1006 // Naming Styles
            public string table_name { get; set; } = null!;
            public string column_name { get; set; } = null!;
            public string is_nullable { get; set; } = null!;
            public string data_type { get; set; } = null!;
            public string column_type { get; set; } = null!;
            public string module { get; set; } = null!;
            public string doctype { get; set; } = null!;
#pragma warning restore IDE1006 // Naming Styles
        }

    }
}
