
using System.Data;
using System.Globalization;
using System.Text.RegularExpressions;
using System.Text;
using System.Reflection;
using System.Text.Json;
using static MyApp.Program;

namespace MyApp // Note: actual namespace depends on the project name.
{
    internal class Program
    {

        static void Main(string[] args)
        {

            Console.WriteLine("Starting...");

            var camelizer = new Regex("[^a-zA-Z0-9._]");

            var schema = GetColumnInfo();
            Console.WriteLine($"Found {schema.Count} columns to reconstruct...");

            var projectDirectory = new DirectoryInfo(Directory.GetCurrentDirectory());
            while (true)
            {
                if (projectDirectory is null)
                {
                    Console.WriteLine($"ERROR: Failed to find project folder! Exiting...");
                    return;
                }
                if ("gizmofort.connector.erpnext" == projectDirectory.Name)
                    break;
                projectDirectory = projectDirectory.Parent;
            }
            var outputFolder = Path.Combine(projectDirectory.FullName, @"Libs\GizmoFort.Connector.ERPNext\ERPTypes");
            var unitTestOutputFolder = Path.Combine(projectDirectory.FullName, @"Tests\GizmoFort.Connector.ERPNext.Tests\TestData");
            Console.WriteLine($"Exporting generated code to {outputFolder}...");
            if (!Directory.Exists(outputFolder))
                Directory.CreateDirectory(outputFolder);

            var banner =
@"/********************************************************************
    This file has been auto-generated by GenerateCodeFromSchemaJson
    created date: " + DateTime.Now.ToString("G") + @"
********************************************************************/";

            var docTypesLines = new StringBuilder();
            var servicesUsings = new StringBuilder();
            var servicesProperties = new StringBuilder();
            var servicesConstructor = new StringBuilder();

            var modules = schema
                            .GroupBy(c => c.module)
                            .Select(g => g.Key)
                            .ToList();
            foreach (var module in modules)
            {
                var camelizedModule = camelizer.Replace($"{module}", "");

                var moduleFolder = Path.Combine(outputFolder, camelizedModule);
                if (!Directory.Exists(moduleFolder))
                    Directory.CreateDirectory(moduleFolder);

                var doctypes = schema
                                 .Where(c => c.module == module)
                                 .GroupBy(c => c.doctype)
                                 .Select(g => g.Key)
                                 .ToList();
                foreach (var doctype in doctypes)
                {
                    var camelizedDoctype = camelizer.Replace($"{doctype}", "");

                    Console.WriteLine($"Processing doctype '{camelizedModule}.{camelizedDoctype}'...");

                    var doctypeFolder = Path.Combine(outputFolder, camelizedModule, camelizedDoctype);
                    if (!Directory.Exists(doctypeFolder))
                        Directory.CreateDirectory(doctypeFolder);

                    var columnInfos = schema
                                        .Where(c => c.module == module
                                                    && c.doctype == doctype)
                                        .ToList();

                    var camelizedModuleNamespace = KeywordFixup(camelizedModule, "_");
                    var camelizedDoctypeNamespace = KeywordFixup(camelizedDoctype, "_");

                    var @namespace = $"GizmoFort.Connector.ERPNext.ERPTypes.{camelizedModuleNamespace}.{camelizedDoctypeNamespace}";
                    var typePrefix = $"ERP_{camelizedModule}_{camelizedDoctype}";
                    var doctypeEnumValue = $"{camelizedModule}_{camelizedDoctype}";
                    var modelClassName = $"ERP_{camelizedModule}_{camelizedDoctype}";
                    var serviceClassName = $"{camelizedModule}_{camelizedDoctype}_Service";

                    bool forceRegenerateAllFiles = false;

                    //
                    // user-customizable model file
                    //
                    {
                        var columnInfo = columnInfos
                                                .Where(c => c.column_name == "name")
                                                .First();
                        var nameCSharpType = GetCSharpTypeFromColumnInfo(columnInfo);

                        var fileContents =
@"" + banner + @"

using GizmoFort.Connector.ERPNext.WrapperTypes;

namespace " + @namespace + @"
{
    /*** NOTE: This file can be modified and will not be re-generated unless deleted ***/

    public partial class " + modelClassName + @" : ERPNextObjectBase
    {
        public static " + modelClassName + @" CreateNew(" + nameCSharpType + @" name /* add other parameters as needed */ )
        {
            " + modelClassName + @" obj = new()
            {
                Name = name
                /* set other properties from parameters here */
            };
            return obj;
        }
    }
}
";
                        var sb = new StringBuilder();

                        sb.Append(fileContents);

                        // create file if it doesn't exist
                        var filename = $"ERP_{camelizedModule}_{camelizedDoctype}.cs";
                        var outputFileFullPath = $"{doctypeFolder}\\{filename}";
                        if (forceRegenerateAllFiles || !File.Exists(outputFileFullPath))
                        {
                            if (File.Exists(outputFileFullPath))
                                File.Delete(outputFileFullPath);
                            using var file = new StreamWriter(outputFileFullPath);
                            file.WriteLine(sb.ToString()); // "sb" is the StringBuilder
                        }
                    }

                    //
                    // auto-generated model file
                    //
                    {
                        var propertiesBuilder = new StringBuilder();
                        foreach (var columnInfo in columnInfos)
                        {
                            var isNullable = columnInfo.is_nullable == "YES";
                            var columnType = columnInfo.column_type;
                            var cSharpType = GetCSharpTypeFromColumnInfo(columnInfo);
                            var columnName = columnInfo.column_name;
                            var hasLeadingUnderscore = columnName[..1] == "_";
                            var optionalUnderscore = hasLeadingUnderscore ? "_" : string.Empty;
                            var columnNamePascalCase = ConvertColumnNameToPascalCase(columnName);
                            var propertyName = $"{optionalUnderscore}{columnNamePascalCase}";
                            var safeColumnName = KeywordFixup(columnName, "@");
                            propertiesBuilder.AppendLine();
                            propertiesBuilder.AppendLine($"        [ColumnInfo(\"{safeColumnName}\", \"{columnType}\", isNullable: {isNullable.ToString().ToLower()})]");

                            switch (columnName)
                            {
                                case "docstatus":
                                    propertiesBuilder.AppendLine($"        public Docstatus {propertyName}");
                                    propertiesBuilder.AppendLine($"        {{");
                                    propertiesBuilder.AppendLine($"            get {{ return (Docstatus)data.{safeColumnName}; }}");
                                    propertiesBuilder.AppendLine($"            set {{ data.{safeColumnName} = (int)value; }}");
                                    propertiesBuilder.AppendLine($"        }}");
                                    break;

                                default:
                                    if (hasLeadingUnderscore)
                                        propertiesBuilder.AppendLine("#pragma warning disable IDE1006 // Naming Styles");
                                    propertiesBuilder.AppendLine($"        public {cSharpType} {propertyName}");
                                    if (hasLeadingUnderscore)
                                        propertiesBuilder.AppendLine("#pragma warning restore IDE1006 // Naming Styles");
                                    propertiesBuilder.AppendLine($"        {{");
                                    var getterFunction = GetGetterFuncFromColumnInfo(columnInfo).Replace("*", $"data.{safeColumnName}");
                                    propertiesBuilder.AppendLine($"            get {{ return {getterFunction}; }}");
                                    var setterFunction = GetSetterFuncFromColumnInfo(columnInfo).Replace("*", "value");
                                    propertiesBuilder.AppendLine($"            set {{ data.{safeColumnName} = {setterFunction}; }}");
                                    propertiesBuilder.AppendLine($"        }}");
                                    break;
                            }

                        }
                        var properties = propertiesBuilder.ToString();


                        var fileContents =
@"" + banner + @"

using System;
using System.ComponentModel.DataAnnotations.Schema;
using GizmoFort.Connector.ERPNext.PublicTypes;
using GizmoFort.Connector.ERPNext.WrapperTypes;
using GizmoFort.Connector.ERPNext.DataAnnotations;
using GizmoFort.Connector.ERPNext.Serialization;
using _DocType = GizmoFort.Connector.ERPNext.PublicTypes.DocType;
using System.Text.Json;

namespace " + @namespace + @"
{
    public partial class " + modelClassName + @" : ERPNextObjectBase
    {
        public " + modelClassName + @"() : this(new ERPObject(_DocType." + doctypeEnumValue + @")) { }
        public " + modelClassName + @"(ERPObject obj) : base(obj) { }

        //public static string? GetColumnName(string propertyName)
        //{
        //    return ERPNextObjectBase.GetColumnName<" + modelClassName + @">(propertyName);
        //}

        //public static string? GetPropertyName(string columnName)
        //{
        //    return ERPNextObjectBase.GetPropertyName<" + modelClassName + @">(columnName);
        //}
" + properties + @"

    }
}
";
                        var sb = new StringBuilder();

                        sb.Append(fileContents);

                        // create file
                        var filename = $"ERP_{camelizedModule}_{camelizedDoctype}.partial.cs";
                        var outputFileFullPath = $"{doctypeFolder}\\{filename}";
                        if (File.Exists(outputFileFullPath))
                            File.Delete(outputFileFullPath);
                        using var file = new StreamWriter(outputFileFullPath);
                        file.WriteLine(sb.ToString()); // "sb" is the StringBuilder
                    }

                    //
                    // user-customizable service file
                    //
                    {

                        var modelContent =
@"" + banner + @"

using GizmoFort.Connector.ERPNext.PublicInterfaces;
using GizmoFort.Connector.ERPNext.PublicInterfaces.SubServices;
using GizmoFort.Connector.ERPNext.PublicTypes;
using _DocType = GizmoFort.Connector.ERPNext.PublicTypes.DocType;

namespace " + @namespace + @"
{
    public class " + serviceClassName + @" : SubServiceBase<" + modelClassName + @">
    {
        public " + serviceClassName + @"(ERPNextClient client) : base(_DocType." + doctypeEnumValue + @", client) { }

        protected override " + modelClassName + @" FromERPObject(ERPObject obj)
        {
            return new " + modelClassName + @"(obj);
        }

        /* custom functions can be added here */

    }
}
";
                        var sb = new StringBuilder();

                        sb.Append(modelContent);

                        // create file if it doesn't exist
                        var filename = $"{camelizedModule}_{camelizedDoctype}_Service.cs";
                        var outputFileFullPath = $"{doctypeFolder}\\{filename}";
                        if (forceRegenerateAllFiles || !File.Exists(outputFileFullPath))
                        {
                            if (File.Exists(outputFileFullPath))
                                File.Delete(outputFileFullPath);
                            using var file = new StreamWriter(outputFileFullPath);
                            file.WriteLine(sb.ToString()); // "sb" is the StringBuilder
                        }
                    }

                    //
                    // doctypes lines
                    //
                    {
                        docTypesLines.AppendLine($"        public static readonly DocType {doctypeEnumValue} = new(\"{doctype}\");");
                    }

                    //
                    // services lines
                    //
                    if (serviceClassName != "UnitTestingOnly_TestType_Service")
                    {
                        servicesUsings.AppendLine($"using {@namespace};");
                        servicesProperties.AppendLine($"        public {serviceClassName} {serviceClassName} {{ get; }}");
                        servicesConstructor.AppendLine($"            this.{serviceClassName} = new {serviceClassName}(Client);");
                    }


                }


            }

            //
            // replace doctypes in:
            // gizmofort.connector.erpnext\Libs\GizmoFort.Connector.ERPNext\PublicTypes\DocType.cs
            //
            {
                Console.WriteLine(@"Replace old doctypes from GizmoFort.Connector.ERPNext\PublicTypes\DocType.cs...");
                var docTypeCsFile = Path.Combine(projectDirectory.FullName, @"Libs\GizmoFort.Connector.ERPNext\PublicTypes\DocType.cs");
                var docTypeCsFileTemp = $"{docTypeCsFile}temp";
                var lines = File.ReadAllLines(docTypeCsFile);
                using StreamWriter output = new(docTypeCsFileTemp);
                bool newLinesInserted = false;
                foreach (var line in lines)
                {
                    if (!line.Contains("public static readonly DocType"))
                    {
                        output.WriteLine(line);
                    }
                    else if (!newLinesInserted)
                    {
                        output.Write(docTypesLines.ToString());
                        newLinesInserted = true;
                    }
                }
                output.Flush();
                output.Close();
                File.Move(docTypeCsFileTemp, docTypeCsFile, true);
            }

            //
            // replace main servies file in:
            // GizmoFort.Connector.ERPNext\PublicInterfaces\ERPNextServices.cs
            //
            {
                Console.WriteLine(@"Replace main servies file at GizmoFort.Connector.ERPNext\PublicInterfaces\ERPNextServices.cs...");

                var fileContents =
@"" + banner + @"

" + servicesUsings.ToString() + @"
using GizmoFort.Connector.ERPNext.PublicInterfaces.SubServices;

namespace GizmoFort.Connector.ERPNext.PublicInterfaces
{
    public class ERPNextServices
    {
        public ERPNextClient Client { get; }
" + servicesProperties.ToString() + @"

        public ERPNextServices(string domain, string username, string password)
        {
            this.Client = new ERPNextClient(domain, username, password);
" + servicesConstructor.ToString() + @"

        }
    }
}
";
                var sb = new StringBuilder();

                sb.Append(fileContents);

                // create file
                var servicesFileFullPath = Path.Combine(projectDirectory.FullName, @"Libs\GizmoFort.Connector.ERPNext\PublicInterfaces\ERPNextServices.cs");
                if (File.Exists(servicesFileFullPath))
                    File.Delete(servicesFileFullPath);
                using var file = new StreamWriter(servicesFileFullPath);
                file.WriteLine(sb.ToString()); // "sb" is the StringBuilder
            }

            //
            // move unit test data to correct location
            //
            {
                var sourceFolder = Path.Combine(outputFolder, "UnitTestingOnly");
                var destFolder = Path.Combine(unitTestOutputFolder, "UnitTestingOnly");

                if (Directory.Exists(destFolder))
                    Directory.Delete(destFolder, recursive: true);

                Directory.Move(sourceFolder,destFolder);

                //
                // only need the partial
                //
                var testTypeFolder = Path.Combine(destFolder, "TestType");
                foreach (var filePath in Directory.GetFiles(testTypeFolder))
                {
                    var fileInfo = new FileInfo(filePath);
                    if (fileInfo.Name.EndsWith(".partial.cs"))
                    {
                        var fileDestPath = Path.Combine(unitTestOutputFolder, fileInfo.Name);
                        if (File.Exists(fileDestPath))
                            File.Delete(fileDestPath);
                        File.Move(filePath, fileDestPath);
                    }
                }
                Directory.Delete(destFolder, recursive: true);

            }


            Console.WriteLine("Done!");

        }

        static string ConvertColumnNameToPascalCase(string columnName)
        {
            var noUnderscores = columnName.ToLower().Replace("_", " ");
            TextInfo info = CultureInfo.CurrentCulture.TextInfo;
            var propertyName = info.ToTitleCase(noUnderscores).Replace(" ", string.Empty);
            return propertyName;
        }

        static string KeywordFixup(string name, string prefix)
        {
            return name switch
            {
                "abstract" => $"{prefix}abstract",
                "as" => $"{prefix}as",
                "base" => $"{prefix}base",
                "bool" => $"{prefix}bool",
                "break" => $"{prefix}break",
                "byte" => $"{prefix}byte",
                "case" => $"{prefix}case",
                "catch" => $"{prefix}catch",
                "char" => $"{prefix}char",
                "checked" => $"{prefix}checked",
                "class" => $"{prefix}class",
                "const" => $"{prefix}const",
                "continue" => $"{prefix}continue",
                "decimal" => $"{prefix}decimal",
                "default" => $"{prefix}default",
                "delegate" => $"{prefix}delegate",
                "do" => $"{prefix}do",
                "double" => $"{prefix}double",
                "else" => $"{prefix}else",
                "enum" => $"{prefix}enum",
                "event" => $"{prefix}event",
                "explicit" => $"{prefix}explicit",
                "extern" => $"{prefix}extern",
                "false" => $"{prefix}false",
                "finally" => $"{prefix}finally",
                "fixed" => $"{prefix}fixed",
                "float" => $"{prefix}float",
                "for" => $"{prefix}for",
                "foreach" => $"{prefix}foreach",
                "goto" => $"{prefix}goto",
                "if" => $"{prefix}if",
                "implicit" => $"{prefix}implicit",
                "in" => $"{prefix}in",
                "int" => $"{prefix}int",
                "interface" => $"{prefix}interface",
                "internal" => $"{prefix}internal",
                "is" => $"{prefix}is",
                "lock" => $"{prefix}lock",
                "long" => $"{prefix}long",
                "namespace" => $"{prefix}namespace",
                "new" => $"{prefix}new",
                "null" => $"{prefix}null",
                "object" => $"{prefix}object",
                "operator" => $"{prefix}operator",
                "out" => $"{prefix}out",
                "override" => $"{prefix}override",
                "params" => $"{prefix}params",
                "private" => $"{prefix}private",
                "protected" => $"{prefix}protected",
                "public" => $"{prefix}public",
                "readonly" => $"{prefix}readonly",
                "ref" => $"{prefix}ref",
                "return" => $"{prefix}return",
                "sbyte" => $"{prefix}sbyte",
                "sealed" => $"{prefix}sealed",
                "short" => $"{prefix}short",
                "sizeof" => $"{prefix}sizeof",
                "stackalloc" => $"{prefix}stackalloc",
                "static" => $"{prefix}static",
                "string" => $"{prefix}string",
                "struct" => $"{prefix}struct",
                "switch" => $"{prefix}switch",
                "this" => $"{prefix}this",
                "throw" => $"{prefix}throw",
                "TRUE" => $"{prefix}TRUE",
                "try" => $"{prefix}try",
                "typeof" => $"{prefix}typeof",
                "uint" => $"{prefix}uint",
                "ulong" => $"{prefix}ulong",
                "unchecked" => $"{prefix}unchecked",
                "unsafe" => $"{prefix}unsafe",
                "ushort" => $"{prefix}ushort",
                "using" => $"{prefix}using",
                "virtual" => $"{prefix}virtual",
                "void" => $"{prefix}void",
                "volatile" => $"{prefix}volatile",
                "while" => $"{prefix}while",
                "add" => $"{prefix}add",
                "and" => $"{prefix}and",
                "alias" => $"{prefix}alias",
                "ascending" => $"{prefix}ascending",
                "args" => $"{prefix}args",
                "async" => $"{prefix}async",
                "await" => $"{prefix}await",
                "by" => $"{prefix}by",
                "descending" => $"{prefix}descending",
                "dynamic" => $"{prefix}dynamic",
                "equals" => $"{prefix}equals",
                "from" => $"{prefix}from",
                "get" => $"{prefix}get",
                "global" => $"{prefix}global",
                "group" => $"{prefix}group",
                "init" => $"{prefix}init",
                "into" => $"{prefix}into",
                "join" => $"{prefix}join",
                "let" => $"{prefix}let",
                "managed" => $"{prefix}managed",
                "nameof" => $"{prefix}nameof",
                "nint" => $"{prefix}nint",
                "not" => $"{prefix}not",
                "notnull" => $"{prefix}notnull",
                "nuint" => $"{prefix}nuint",
                "on" => $"{prefix}on",
                "or" => $"{prefix}or",
                "orderby" => $"{prefix}orderby",
                "partial" => $"{prefix}partial",
                "record" => $"{prefix}record",
                "remove" => $"{prefix}remove",
                "required" => $"{prefix}required",
                "select" => $"{prefix}select",
                "set" => $"{prefix}set",
                "unmanaged" => $"{prefix}unmanaged",
                "value" => $"{prefix}value",
                "var" => $"{prefix}var",
                "when" => $"{prefix}when",
                "where" => $"{prefix}where",
                "with" => $"{prefix}with",
                "yield" => $"{prefix}yield",
                _ => name
            };
        }

        static string GetCSharpTypeFromColumnInfo(ColumnInfo columnInfo)
        {
            var isNullable = columnInfo.column_name != "name" && columnInfo.is_nullable == "YES";

            if (columnInfo.column_type == "int(1)")
                return "bool" + (isNullable ? "?" : string.Empty);

            return columnInfo.data_type switch
            {
                "int" => "int",
                "decimal" => "decimal",
                "text" => "string",
                "varchar" => "string",
                "datetime" => "DateTimeOffset",
                "time" => "TimeSpan",
                "date" => "DateOnly",
                "bigint" => "long",
                "longtext" => "string",
                _ => "object",
            } + (isNullable ? "?" : string.Empty);
        }
        static string GetGetterFuncFromColumnInfo(ColumnInfo columnInfo)
        {
            var isNullable = columnInfo.column_name != "name" && columnInfo.is_nullable == "YES";

            if (columnInfo.column_type == "int(1)")
                return (isNullable ? "ERPNextConverter.NullableIntToBool((int)*)" : "ERPNextConverter.IntToBool((int)*)");

            return columnInfo.data_type switch
            {
                "int" => "*",
                "decimal" => "*",
                "text" => "*",
                "varchar" => "*",
                "datetime" => "ERPNextConverter.StringToDateTimeOffset(*)",
                "time" => "ERPNextConverter.StringToTimeSpan(*)",
                "date" => "ERPNextConverter.StringToDateOnly(*)",
                "bigint" => "*",
                "longtext" => "*",
                _ => "*",
            };
        }

        static string GetSetterFuncFromColumnInfo(ColumnInfo columnInfo)
        {
            var isNullable = columnInfo.column_name != "name" && columnInfo.is_nullable == "YES";

            if (columnInfo.column_type == "int(1)")
                return (isNullable ? "ERPNextConverter.NullableBoolToInt(*)" : "ERPNextConverter.BoolToInt(*)");

            var nullForgivenessOperator = (isNullable ? "!" : string.Empty);

            var fracSecs = columnInfo.FractionalSecondsDigits != -1 ? $", {columnInfo.FractionalSecondsDigits}" : String.Empty;
            var stringCvt = columnInfo.StringLength != -1 ? $"ERPNextConverter.TruncateString(*, {columnInfo.StringLength})" : "*";

            return columnInfo.data_type switch
            {
                "int" => "*",
                "decimal" => "*",
                "text" => $"{stringCvt}",
                "varchar" => $"{stringCvt}",
                "datetime" => $"ERPNextConverter.DateTimeOffsetToString(*{fracSecs})",
                "time" => $"ERPNextConverter.TimeSpanToString(*{fracSecs})",
                "date" => $"ERPNextConverter.DateOnlyToString(*{fracSecs})",
                "bigint" => "*",
                "longtext" => $"{stringCvt}",
                _ => "*",
            };
        }

        static IList<ColumnInfo> GetColumnInfo()
        {
            var columnInfos = new List<ColumnInfo>();

            var assembly = Assembly.GetExecutingAssembly();

            var resourceName = "GenerateCodeFromSchemaJson.schema_14.0.3.json";
            using (var stream = assembly.GetManifestResourceStream(resourceName))
            {
                using var reader = new StreamReader(stream!);
                var schemaJson = reader.ReadToEnd();
                var columnInfo = JsonSerializer.Deserialize<AllColumnInfos>(schemaJson);
                columnInfos.AddRange(columnInfo!.schema);
            }

            resourceName = "GenerateCodeFromSchemaJson.unit_test_schema.json";
            using (var stream = assembly.GetManifestResourceStream(resourceName))
            {
                using var reader = new StreamReader(stream!);
                var schemaJson = reader.ReadToEnd();
                var columnInfo = JsonSerializer.Deserialize<AllColumnInfos>(schemaJson);
                columnInfos.AddRange(columnInfo!.schema);
            }

            return columnInfos;
        }

        public class AllColumnInfos
        {
#pragma warning disable IDE1006 // Naming Styles
            public List<ColumnInfo> schema { get; set; } = null!;
#pragma warning restore IDE1006 // Naming Styles
        }

        public class ColumnInfo
        {
#pragma warning disable IDE1006 // Naming Styles
            public string table_name { get; set; } = null!;
            public string column_name { get; set; } = null!;
            public string is_nullable { get; set; } = null!;
            public string data_type { get; set; } = null!;
            public string column_type { get; set; } = null!;
            public string module { get; set; } = null!;
            public string doctype { get; set; } = null!;
#pragma warning restore IDE1006 // Naming Styles

            private int _intDisplayWidth = -1;
            /// <summary>
            /// NOTE: This value is relevant to the client only (i.e. for use with display padding). Integers of any width can be transmitted to the database.
            /// </summary>
            public int IntDisplayWidth { get { GetTypeParameters(); return _intDisplayWidth; } }

            private int _decimalPrecision = -1;
            public int DecimalPrecision { get { GetTypeParameters(); return _decimalPrecision; } }

            private int _decimalScale = -1;
            public int DecimalScale { get { GetTypeParameters(); return _decimalScale; } }

            private int _stringLength = -1;
            public int StringLength { get { GetTypeParameters(); return _stringLength; } }

            private int _fractionalSecondsDigits = -1;
            public int FractionalSecondsDigits { get { GetTypeParameters(); return _fractionalSecondsDigits; } }

            private bool _analyzed = false;

            private void GetTypeParameters()
            {
                if (!_analyzed)
                {
                    var pattern = "([a-zA-Z]+)(?:\\((\\d+)(?:\\,*(\\d+))*\\))";
                    var match = Regex.Match(column_type, pattern);

                    string parsed_data_type = match.Groups[1].Value.ToLower();
                    int? parameter1 = string.IsNullOrEmpty(match.Groups[2].Value) ? null : int.Parse(match.Groups[2].Value);
                    int? parameter2 = string.IsNullOrEmpty(match.Groups[3].Value) ? null : int.Parse(match.Groups[3].Value);

                    if (parsed_data_type == data_type.ToLower())
                    {
                        switch (parsed_data_type)
                        {
                            case "int":
                            case "bigint":
                                if (parameter1.HasValue) _intDisplayWidth = parameter1.Value;
                                break;

                            case "decimal":
                                if (parameter1.HasValue) _decimalPrecision = parameter1.Value;
                                if (parameter2.HasValue) _decimalScale = parameter2.Value;
                                break;

                            case "longtext":
                            case "text":
                            case "varchar":
                            case "nvarchar":
                                if (parameter1.HasValue) _stringLength = parameter1.Value;
                                break;

                            case "datetime":
                            case "time":
                                if (parameter1.HasValue) _fractionalSecondsDigits = parameter1.Value;
                                break;

                            case "date":
                                break;

                        }
                    }

                    _analyzed = true;
                }
            }

        }

    }
}
